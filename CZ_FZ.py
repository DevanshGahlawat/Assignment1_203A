# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yOBSO-Sia2Xsb1QRY6PnIyQHYiPGWOi6
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Parameters
L = 1.0
w = L/100   # melt-zone width
k = 0.8
x_frac_CZ = np.linspace(0, 0.999, 500)  # avoid div by zero at 1
x_frac_FZ = np.linspace(0, L, 2000)

# --- CZ method ---
C_CZ = k * (1 - x_frac_CZ)**(k - 1)

# --- FZ method ---
def C_over_CM_FZ(x, L, w, k):
    """Return C(x)/CM for Floating Zone (FZ)."""
    if x <= (L - w):  # interior zone (constant melt volume)
        return 1 + (k - 1) * np.exp(-k * x / w)
    else:  # end zone (shrinking melt volume -> impurity spike)
        delta_x = x - (L - w)
        V_x = w - delta_x
        if V_x <= 0:
            return np.inf
        C_start = 1 + (k - 1) * np.exp(-k * (L - w) / w)
        return C_start * (w / V_x)

C_FZ = [C_over_CM_FZ(x, L, w, k) for x in x_frac_FZ]

# --- Save to Excel ---
df_CZ = pd.DataFrame({"x/L": x_frac_CZ, "CZ (k=0.8)": C_CZ})
df_FZ = pd.DataFrame({"x/L": x_frac_FZ, "FZ (k=0.8)": C_FZ})

output_path = "CZ_vs_FZ_profiles.xlsx"
with pd.ExcelWriter(output_path, engine="openpyxl") as writer:
    df_CZ.to_excel(writer, sheet_name="CZ", index=False)
    df_FZ.to_excel(writer, sheet_name="FZ", index=False)

print(f"Excel file saved as {output_path}")

# --- Plot comparison ---
plt.figure(figsize=(8,6))
plt.semilogy(df_CZ["x/L"], df_CZ["CZ (k=0.8)"], 'b--', label=f'CZ, k={k}')
plt.semilogy(df_FZ["x/L"], df_FZ["FZ (k=0.8)"], 'r-', label=f'FZ, k={k}')
plt.xlabel("x/L")
plt.ylabel("C(x)/CM")
plt.title(f"Comparison of CZ vs FZ (w/L={w/L:.3f}, k={k})")
plt.legend()
plt.grid(True, which="both", linestyle="--")
plt.show()

# --- Download in Colab ---
from google.colab import files
files.download(output_path)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Parameters
L = 1.0
w = L/100
k = 0.8
N = 2000  # number of points
x_vals = np.linspace(0, L, N)

# --- First pass of FZ ---
def C_over_CM_FZ_first(x, L, w, k):
    if x <= (L - w):
        return 1 + (k - 1) * np.exp(-k * x / w)
    else:
        delta_x = x - (L - w)
        V_x = w - delta_x
        if V_x <= 0:
            return np.inf
        C_start = 1 + (k - 1) * np.exp(-k * (L - w) / w)
        return C_start * (w / V_x)

C_first = np.array([C_over_CM_FZ_first(x, L, w, k) for x in x_vals])

# --- Second pass of FZ ---
def C_over_CM_FZ_second(x, L, w, k, f1):
    """Second pass: f1 is first pass profile at same x."""
    if x <= (L - 2*w):
        return 1 + (k - 1) * np.exp(-k * x / w) * f1[np.searchsorted(x_vals, x)]
    else:
        f_start = 1 + (k - 1) * np.exp(-k * (L - 2*w) / w) * f1[np.searchsorted(x_vals, L - 2*w)]
        return f_start * ((L - x)/(2*w))**(k-1)

C_second = np.array([C_over_CM_FZ_second(x, L, w, k, C_first) for x in x_vals])

# --- Save to Excel ---
df = pd.DataFrame({
    "x/L": x_vals,
    "FZ First Pass": C_first,
    "FZ Second Pass": C_second
})

output_path = "FZ_two_pass_profiles.xlsx"
df.to_excel(output_path, index=False)
print(f"Excel file saved as {output_path}")

# --- Plot ---
plt.figure(figsize=(8,6))
plt.semilogy(x_vals, C_first, 'b--', label="First Pass")
plt.semilogy(x_vals, C_second, 'r-', label="Second Pass")
plt.xlabel("x/L")
plt.ylabel("C(x)/CM")
plt.title(f"Effect of Second FZ Pass (w/L={w/L:.3f}, k={k})")
plt.legend()
plt.grid(True, which="both", linestyle="--")
plt.show()

# --- Download in Colab ---
from google.colab import files
files.download(output_path)

# Corrected FZ Profile with impurity spike near rod end
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Parameters
L = 1.0   # normalize rod length
w = L/100  # fixed melt-zone width
k_values = [0.8, 0.008, 0.00008]  # different segregation coefficients
N = 2000  # number of points

def C_over_CM_FZ(x, L, w, k):
    """Return C(x)/CM for Floating Zone (FZ) with two regimes."""
    if x <= (L - w):  # interior zone (constant melt volume)
        return 1 + (k - 1) * np.exp(-k * x / w)
    else:  # end zone (shrinking melt volume -> impurity spike)
        delta_x = x - (L - w)
        V_x = w - delta_x  # remaining melt length
        if V_x <= 0:  # prevent division by zero
            return np.inf
        # Starting concentration at x = L-w
        C_start = 1 + (k - 1) * np.exp(-k * (L - w) / w)
        # Impurity conservation effect: concentration increases as melt shrinks
        return C_start * (w / V_x)

# Generate data
results = {}
x_vals = np.linspace(0, L, N)

for k in k_values:
    C_vals = [C_over_CM_FZ(x, L, w, k) for x in x_vals]
    results[f"k = {k}"] = C_vals

# Create DataFrame
df = pd.DataFrame({"x/L": x_vals})
for key, val in results.items():
    df[key] = val

# Save to Excel
output_path = "FZ_Cx_over_CM_k_variation_corrected.xlsx"
df.to_excel(output_path, index=False)

# Plot (semilog Y)
plt.figure(figsize=(8,6))
for key in results:
    plt.semilogy(x_vals, results[key], label=key)
plt.xlabel("x/L")
plt.ylabel("C(x)/CM")
plt.title(f"FZ Method: Impurity Profile for w/L = {w/L:.3f}")
plt.legend()
plt.grid(True, which="both", linestyle="--")
plt.show()

# Download snippet for Colab
from google.colab import files
files.download(output_path)

import numpy as np
import pandas as pd
from google.colab import files

# Parameters
k = 0.8
L = 1.0   # normalize rod length
CM = 1.0  # normalize impurity concentration

# Zone widths
w_values = [L/10, L/100, L/1000]

# Discretization
N = 1000
x = np.linspace(0, L, N)

# Storage for results
data = {"x/L": x/L}

# Function for C(x)/CM in FZ
def C_over_CM(x, L, w, k):
    x0 = L - w  # when zone starts shrinking
    Cx = np.zeros_like(x)
    # Region 1: constant zone length
    mask1 = x <= x0
    Cx[mask1] = 1.0 + (k - 1.0) * np.exp(-k * x[mask1] / w)
    # Region 2: shrinking zone at rod end
    mask2 = x > x0
    if np.any(mask2):
        S0_prime = (CM * L / k) * (1.0 + (k - 1.0) * np.exp(-k * x0 / w)) * (w/L)
        Cx[mask2] = (k * S0_prime / (L - x0)**k) * (L - x[mask2])**(k - 1.0) / (CM * (L - x[mask2]) / (L))
    return Cx

# Compute curves for each w
for w in w_values:
    data[f"C(x)/CM, w={w:.5f}"] = C_over_CM(x, L, w, k)

# Create DataFrame
df = pd.DataFrame(data)

# Save to Excel
output_path = "FZ_Cx_over_CM.xlsx"
df.to_excel(output_path, index=False)

# Download the Excel file in Colab
files.download(output_path)

import numpy as np
import pandas as pd

# Parameters
L = 1.0   # normalized length (use x/L)
x_frac = np.linspace(0, 0.999, 500)  # avoid division by zero at x/L=1
CM = 1.0  # normalize CM

# Distribution coefficients to plot
k_values = [0.80, 0.008, 0.00008]

# Compute C(x)/CM for each k
data = {"x/L": x_frac}
for k in k_values:
    C_over_CM = k * (1 - x_frac)**(k - 1)
    data[f"C(x)/CM (k={k})"] = C_over_CM

# Convert to DataFrame
df = pd.DataFrame(data)

# Save to Excel in Colab working directory
output_path = "Cx_over_CM_data.xlsx"
df.to_excel(output_path, index=False)

print(f"Excel file saved as {output_path}")

from google.colab import files
files.download("Cx_over_CM_data.xlsx")